<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Исследование цветовых моделей</title>
    <style>
        /* CSS переменные для единообразного управления цветами */
        :root {
            --primary-color: #3498db;
            --secondary-color: #2c3e50;
            --background-color: #f5f7fa;
            --text-color: #333;
            --border-color: #ddd;
            --notification-color: #e74c3c;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            background-color: var(--background-color);
            margin: 0;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            padding: 20px;
        }

        h1, h2, h3 {
            color: var(--secondary-color);
        }

        /* Блок отображения текущего выбранного цвета */
        .color-display {
            width: 100%;
            height: 150px;
            border-radius: 8px;
            margin: 20px 0;
            border: 1px solid var(--border-color);
            transition: background-color 0.3s;
        }

        /* Сетка для отображения трех цветовых моделей */
        .color-models {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .color-model {
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 15px;
            background: #f9f9f9;
        }

        .color-model h3 {
            margin-top: 0;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 10px;
        }

        .color-inputs {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        /* Группа ввода: метка + слайдер + числовое поле */
        .input-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .input-group label {
            min-width: 40px;
            font-weight: bold;
        }

        .input-group input[type="range"] {
            flex: 1;
        }

        .input-group input[type="number"] {
            width: 70px;
            padding: 5px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
        }

        /* Контейнер для цветового пикера */
        .color-picker-container {
            margin: 20px 0;
            position: relative;
        }

        .color-picker-wrapper {
            position: relative;
            width: 100%;
            height: 200px;
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid var(--border-color);
        }

        .color-picker {
            width: 100%;
            height: 100%;
            cursor: crosshair;
            display: block;
        }

        /* Курсор для выбора цвета на палитре */
        .color-picker-cursor {
            position: absolute;
            width: 15px;
            height: 15px;
            border: 2px solid white;
            border-radius: 50%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.8);
            pointer-events: none;
            transform: translate(-50%, -50%);
        }

        /* Контейнер для слайдера оттенка */
        .hue-slider-container {
            margin-top: 15px;
            position: relative;
            height: 30px;
            border-radius: 15px;
            overflow: hidden;
            border: 1px solid var(--border-color);
        }

        .hue-slider {
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        /* Курсор для слайдера оттенка */
        .hue-slider-cursor {
            position: absolute;
            width: 20px;
            height: 20px;
            border: 2px solid white;
            border-radius: 50%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.8);
            pointer-events: none;
            top: 50%;
            transform: translate(-50%, -50%);
        }

        /* Панель инструментов с кнопками */
        .tools {
            display: flex;
            gap: 10px;
            margin: 20px 0;
        }

        button {
            padding: 10px 15px;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.3s;
        }

        button:hover {
            background: #2980b9;
        }

        /* Ввод HEX значения */
        .hex-input {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 20px 0;
        }

        .hex-input input {
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-family: monospace;
            font-size: 1.1em;
            width: 120px;
        }

        /* Уведомление */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: var(--notification-color);
            color: white;
            padding: 15px 20px;
            border-radius: 4px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            opacity: 0;
            transform: translateY(-20px);
            transition: opacity 0.3s, transform 0.3s;
        }

        .notification.show {
            opacity: 1;
            transform: translateY(0);
        }

        @media (max-width: 768px) {
            .color-models {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
<div class="container">
    <h1>Исследование цветовых моделей</h1>

    <!-- Блок отображения текущего выбранного цвета -->
    <div class="color-display" id="colorDisplay"></div>

    <!-- Ввод HEX значения цвета -->
    <div class="hex-input">
        <label for="hexInput">HEX:</label>
        <input type="text" id="hexInput" value="#3498db">
        <button id="applyHex">Применить</button>
    </div>

    <!-- Цветовой пикер с палитрой и слайдером оттенка -->
    <div class="color-picker-container">
        <h3>Выбор цвета</h3>
        <div class="color-picker-wrapper">
            <canvas id="colorPicker" class="color-picker" width="400" height="200"></canvas>
            <div class="color-picker-cursor" id="colorPickerCursor"></div>
        </div>

        <div class="hue-slider-container">
            <canvas id="hueSlider" class="hue-slider" width="400" height="30"></canvas>
            <div class="hue-slider-cursor" id="hueSliderCursor"></div>
        </div>
    </div>

    <!-- Панель инструментов -->
    <div class="tools">
        <button id="randomColor">Случайный цвет</button>
        <button id="resetColor">Сбросить</button>
    </div>

    <!-- Секции для трех цветовых моделей: RGB, HSV, LAB -->
    <div class="color-models">
        <!-- Модель RGB -->
        <div class="color-model">
            <h3>RGB</h3>
            <div class="color-inputs">
                <div class="input-group">
                    <label for="rSlider">R:</label>
                    <input type="range" id="rSlider" min="0" max="255">
                    <label for="rInput"></label>
                    <input type="number" id="rInput" min="0" max="255">
                </div>
                <div class="input-group">
                    <label for="gSlider">G:</label>
                    <input type="range" id="gSlider" min="0" max="255">
                    <label for="gInput"></label>
                    <input type="number" id="gInput" min="0" max="255">
                </div>
                <div class="input-group">
                    <label for="rgbBSlider">B:</label>
                    <input type="range" id="rgbBSlider" min="0" max="255">
                    <label for="rgbBInput"></label>
                    <input type="number" id="rgbBInput" min="0" max="255">
                </div>
            </div>
        </div>

        <!-- Модель HSV -->
        <div class="color-model">
            <h3>HSV</h3>
            <div class="color-inputs">
                <div class="input-group">
                    <label for="hSlider">H:</label>
                    <input type="range" id="hSlider" min="0" max="360">
                    <label for="hInput"></label>
                    <input type="number" id="hInput" min="0" max="360">
                </div>
                <div class="input-group">
                    <label for="sSlider">S:</label>
                    <input type="range" id="sSlider" min="0" max="100">
                    <label for="sInput"></label><input type="number" id="sInput" min="0" max="100">
                </div>
                <div class="input-group">
                    <label for="vSlider">V:</label>
                    <input type="range" id="vSlider" min="0" max="100">
                    <label for="vInput"></label>
                    <input type="number" id="vInput" min="0" max="100">
                </div>
            </div>
        </div>

        <!-- Модель LAB -->
        <div class="color-model">
            <h3>LAB</h3>
            <div class="color-inputs">
                <div class="input-group">
                    <label for="lSlider">L:</label>
                    <input type="range" id="lSlider" min="0" max="100">
                    <label for="lInput"></label>
                    <input type="number" id="lInput" min="0" max="100">
                </div>
                <div class="input-group">
                    <label for="aSlider">A:</label>
                    <input type="range" id="aSlider" min="-128" max="127">
                    <label for="aInput"></label>
                    <input type="number" id="aInput" min="-128" max="127">
                </div>
                <div class="input-group">
                    <label for="bSlider">B:</label>
                    <input type="range" id="bSlider" min="-128" max="127">
                    <label for="bInput"></label>
                    <input type="number" id="bInput" min="-128" max="127">
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Уведомление -->
<div class="notification" id="notification"></div>

<script>
    // Текущий цвет представлен в трех цветовых моделях
    let currentColor = {
        rgb: {r: 52, g: 152, b: 219 },  // RGB значения (0-255)
        hsv: {h: 204, s: 76, v: 86 },   // HSV значения (H:0-360, S:0-100, V:0-100)
        lab: {l: 59, a: -10, b: -39}    // LAB значения (L:0-100, A:-128-127, B:-128-127)
    };

    // Элементы для уведомлений
    const notification = document.getElementById('notification');
    let notificationTimeout;

    // Элементы цветового пикера
    const colorPicker = document.getElementById('colorPicker');
    const colorPickerCursor = document.getElementById('colorPickerCursor');
    const hueSlider = document.getElementById('hueSlider');
    const hueSliderCursor = document.getElementById('hueSliderCursor');

    // Контексты рисования для canvas элементов
    const colorPickerCtx = colorPicker.getContext('2d');
    const hueSliderCtx = hueSlider.getContext('2d');

    // Текущий оттенок для цветового пикера
    let currentHue = 204;

    // Размеры canvas элементов
    const colorPickerWidth = 400;
    const colorPickerHeight = 200;
    const hueSliderWidth = 400;
    const hueSliderHeight = 30;

    // Установка размеров canvas
    colorPicker.width = colorPickerWidth;
    colorPicker.height = colorPickerHeight;
    hueSlider.width = hueSliderWidth;
    hueSlider.height = hueSliderHeight;

    // Инициализация приложения после загрузки DOM
    document.addEventListener('DOMContentLoaded', function() {
        initColorPicker();
        initHueSlider();
        updateAllDisplays();
        setupEventListeners();
        updateColorPickerCursor();
        updateHueSliderCursor();
    });

    // Инициализация цветового пикера
    function initColorPicker() {
        drawColorPicker();

        // Обработчик кликов на палитре
        colorPicker.addEventListener('click', handleColorPickerClick);

        // Обработчики для перетаскивания курсора
        let isDragging = false;
        colorPicker.addEventListener('mousedown', function(e) {
            isDragging = true;
            handleColorPickerClick(e);
        });

        document.addEventListener('mousemove', function(e) {
            if (isDragging) {
                handleColorPickerClick(e);
            }
        });

        document.addEventListener('mouseup', function() {
            isDragging = false;
        });
    }

    // Обработка клика на цветовом пикере
    function handleColorPickerClick(e) {
        const rect = colorPicker.getBoundingClientRect();
        const scaleX = colorPickerWidth / rect.width;
        const scaleY = colorPickerHeight / rect.height;

        // Вычисление координат с учетом масштаба
        const x = Math.max(0, Math.min(colorPickerWidth, (e.clientX - rect.left) * scaleX));
        const y = Math.max(0, Math.min(colorPickerHeight, (e.clientY - rect.top) * scaleY));

        // Преобразование координат в значения насыщенности и яркости
        const s = x / colorPickerWidth;
        const v = 1 - (y / colorPickerHeight);

        // Обновление HSV значений
        hsvValuesUpdated(currentHue, s * 100, v * 100);
        updateColorPickerCursor();
    }

    // Инициализация слайдера оттенка
    function initHueSlider() {
        drawHueSlider();

        // Обработчик кликов на слайдере оттенка
        hueSlider.addEventListener('click', handleHueSliderClick);

        // Обработчики для перетаскивания курсора слайдера
        let isHueDragging = false;
        hueSlider.addEventListener('mousedown', function(e) {
            isHueDragging = true;
            handleHueSliderClick(e);
        });

        document.addEventListener('mousemove', function(e) {
            if (isHueDragging) {
                handleHueSliderClick(e);
            }
        });

        document.addEventListener('mouseup', function() {
            isHueDragging = false;
        });
    }

    // Обработка клика на слайдере оттенка
    function handleHueSliderClick(e) {
        const rect = hueSlider.getBoundingClientRect();
        const scaleX = hueSliderWidth / rect.width;

        // Вычисление координаты X с учетом масштаба
        const x = Math.max(0, Math.min(hueSliderWidth, (e.clientX - rect.left) * scaleX));

        // Преобразование координаты в значение оттенка (0-360)
        currentHue = (x / hueSliderWidth) * 360;

        // Обновление HSV значений и перерисовка
        hsvValuesUpdated(currentHue, currentColor.hsv.s, currentColor.hsv.v);
        drawColorPicker();
        updateColorPickerCursor();
        updateHueSliderCursor();
    }

    // Отрисовка цветовой палитры
    function drawColorPicker() {
        // Очистка canvas
        colorPickerCtx.clearRect(0, 0, colorPickerWidth, colorPickerHeight);

        // Градиент насыщенности (по горизонтали)
        const saturationGradient = colorPickerCtx.createLinearGradient(0, 0, colorPickerWidth, 0);
        saturationGradient.addColorStop(0, 'hsl(' + currentHue + ', 0%, 100%)');  // Белый (0% насыщенности)
        saturationGradient.addColorStop(1, 'hsl(' + currentHue + ', 100%, 50%)'); // Полная насыщенность

        // Градиент яркости (по вертикали)
        const valueGradient = colorPickerCtx.createLinearGradient(0, 0, 0, colorPickerHeight);
        valueGradient.addColorStop(0, 'rgba(255, 255, 255, 0)');  // Прозрачный белый (верх)
        valueGradient.addColorStop(1, 'rgba(0, 0, 0, 1)');        // Черный (низ)

        // Заполнение градиентом насыщенности
        colorPickerCtx.fillStyle = saturationGradient;
        colorPickerCtx.fillRect(0, 0, colorPickerWidth, colorPickerHeight);

        // Наложение градиента яркости с режимом умножения
        colorPickerCtx.fillStyle = valueGradient;
        colorPickerCtx.globalCompositeOperation = 'multiply';
        colorPickerCtx.fillRect(0, 0, colorPickerWidth, colorPickerHeight);
        colorPickerCtx.globalCompositeOperation = 'source-over';
    }

    // Отрисовка слайдера оттенка
    function drawHueSlider() {
        // Очистка canvas
        hueSliderCtx.clearRect(0, 0, hueSliderWidth, hueSliderHeight);

        // Градиент оттенков радуги
        const hueGradient = hueSliderCtx.createLinearGradient(0, 0, hueSliderWidth, 0);

        // Добавление цветовых остановок для плавного градиента
        const hueSteps = 12;
        for (let i = 0; i <= hueSteps; i++) {
            const hue = (i / hueSteps) * 360;
            hueGradient.addColorStop(i / hueSteps, 'hsl(' + hue + ', 100%, 50%)');
        }

        hueSliderCtx.fillStyle = hueGradient;
        hueSliderCtx.fillRect(0, 0, hueSliderWidth, hueSliderHeight);
    }

    // Обновление позиции курсора на цветовой палитре
    function updateColorPickerCursor() {
        // Получение текущих значений насыщенности и яркости
        const s = currentColor.hsv.s / 100;
        const v = currentColor.hsv.v / 100;

        // Вычисление координат курсора
        const x = s * colorPickerWidth;
        const y = (1 - v) * colorPickerHeight;

        // Масштабирование координат под размер контейнера
        const container = colorPicker.parentElement;
        const containerRect = container.getBoundingClientRect();
        const scaleX = containerRect.width / colorPickerWidth;
        const scaleY = containerRect.height / colorPickerHeight;

        // Установка позиции курсора
        colorPickerCursor.style.left = (x * scaleX) + 'px';
        colorPickerCursor.style.top = (y * scaleY) + 'px';
    }

    // Обновление позиции курсора на слайдере оттенка
    function updateHueSliderCursor() {
        // Вычисление координаты X курсора
        const x = (currentHue / 360) * hueSliderWidth;

        // Масштабирование координаты под размер контейнера
        const container = hueSlider.parentElement;
        const containerRect = container.getBoundingClientRect();
        const scaleX = containerRect.width / hueSliderWidth;

        // Установка позиции курсора
        hueSliderCursor.style.left = (x * scaleX) + 'px';
    }

    // Настройка всех обработчиков событий
    function setupEventListeners() {
        // Обработчики для RGB слайдеров и полей ввода
        document.getElementById('rSlider').addEventListener('input', function() {
            rgbValuesUpdated(this.value, currentColor.rgb.g, currentColor.rgb.b);
        });
        document.getElementById('gSlider').addEventListener('input', function() {
            rgbValuesUpdated(currentColor.rgb.r, this.value, currentColor.rgb.b);
        });
        document.getElementById('rgbBSlider').addEventListener('input', function() {
            rgbValuesUpdated(currentColor.rgb.r, currentColor.rgb.g, this.value);
        });

        document.getElementById('rInput').addEventListener('input', function() {
            rgbValuesUpdated(this.value, currentColor.rgb.g, currentColor.rgb.b);
        });
        document.getElementById('gInput').addEventListener('input', function() {
            rgbValuesUpdated(currentColor.rgb.r, this.value, currentColor.rgb.b);
        });
        document.getElementById('rgbBInput').addEventListener('input', function() {
            rgbValuesUpdated(currentColor.rgb.r, currentColor.rgb.g, this.value);
        });

        // Обработчики для HSV слайдеров и полей ввода
        document.getElementById('hSlider').addEventListener('input', function() {
            currentHue = parseInt(this.value);
            hsvValuesUpdated(this.value, currentColor.hsv.s, currentColor.hsv.v);
            drawColorPicker();
            updateColorPickerCursor();
            updateHueSliderCursor();
        });
        document.getElementById('sSlider').addEventListener('input', function() {
            hsvValuesUpdated(currentColor.hsv.h, this.value, currentColor.hsv.v);
            updateColorPickerCursor();
        });
        document.getElementById('vSlider').addEventListener('input', function() {
            hsvValuesUpdated(currentColor.hsv.h, currentColor.hsv.s, this.value);
            updateColorPickerCursor();
        });

        document.getElementById('hInput').addEventListener('input', function() {
            currentHue = parseInt(this.value);
            hsvValuesUpdated(this.value, currentColor.hsv.s, currentColor.hsv.v);
            drawColorPicker();
            updateColorPickerCursor();
            updateHueSliderCursor();
        });
        document.getElementById('sInput').addEventListener('input', function() {
            hsvValuesUpdated(currentColor.hsv.h, this.value, currentColor.hsv.v);
            updateColorPickerCursor();
        });
        document.getElementById('vInput').addEventListener('input', function() {
            hsvValuesUpdated(currentColor.hsv.h, currentColor.hsv.s, this.value);
            updateColorPickerCursor();
        });

        // Обработчики для LAB слайдеров и полей ввода
        document.getElementById('lSlider').addEventListener('input', function() {
            labValuesUpdated(this.value, currentColor.lab.a, currentColor.lab.b);
        });
        document.getElementById('aSlider').addEventListener('input', function() {
            labValuesUpdated(currentColor.lab.l, this.value, currentColor.lab.b);
        });
        document.getElementById('bSlider').addEventListener('input', function() {
            labValuesUpdated(currentColor.lab.l, currentColor.lab.a, this.value);
        });

        document.getElementById('lInput').addEventListener('input', function() {
            labValuesUpdated(this.value, currentColor.lab.a, currentColor.lab.b);
        });
        document.getElementById('aInput').addEventListener('input', function() {
            labValuesUpdated(currentColor.lab.l, this.value, currentColor.lab.b);
        });
        document.getElementById('bInput').addEventListener('input', function() {
            labValuesUpdated(currentColor.lab.l, currentColor.lab.a, this.value);
        });

        // Обработчик для HEX ввода
        document.getElementById('applyHex').addEventListener('click', function() {
            const hex = document.getElementById('hexInput').value;
            // Проверка корректности HEX формата
            if (/^#?[0-9A-F]{6}$/i.test(hex)) {
                const cleanHex = hex.replace('#', '');
                // Разбор HEX значения на компоненты RGB
                const r = parseInt(cleanHex.substring(0, 2), 16);
                const g = parseInt(cleanHex.substring(2, 4), 16);
                const b = parseInt(cleanHex.substring(4, 6), 16);
                rgbValuesUpdated(r, g, b);
            } else {
                alert('Некорректный HEX-формат. Используйте формат #RRGGBB');
            }
        });

        // Обработчики для кнопок
        document.getElementById('randomColor').addEventListener('click', function() {
            // Генерация случайного цвета
            const r = Math.floor(Math.random() * 256);
            const g = Math.floor(Math.random() * 256);
            const b = Math.floor(Math.random() * 256);
            rgbValuesUpdated(r, g, b);
        });

        document.getElementById('resetColor').addEventListener('click', function() {
            // Сброс к черному цвету
            rgbValuesUpdated(0, 0, 0);
        });
    }

    // Обработка обновления RGB значений
    function rgbValuesUpdated(r, g, b) {
        // Проверка диапазонов и обрезка значений
        if (r < 0 || r > 255 || g < 0 || g > 255 || b < 0 || b > 255) {
            showNotification('Цветовые значения были обрезаны для соответствия диапазону RGB');
        }

        // Обновление RGB значений с ограничением диапазона
        currentColor.rgb.r = Math.max(0, Math.min(255, r));
        currentColor.rgb.g = Math.max(0, Math.min(255, g));
        currentColor.rgb.b = Math.max(0, Math.min(255, b));

        // Обновление производных цветовых моделей
        updateHSVValues();
        updateLABValues();
        updateAllDisplays();
        drawColorPicker();
        updateColorPickerCursor();
        updateHueSliderCursor();
    }

    // Обработка обновления HSV значений
    function hsvValuesUpdated(h, s, v) {
        // Проверка диапазонов и обрезка значений
        if (h < 0 || h > 360 || s < 0 || s > 100 || v < 0 || v > 100) {
            showNotification('Цветовые значения были обрезаны для соответствия диапазону HSV');
        }

        // Обновление HSV значений с ограничением диапазона
        currentColor.hsv.h = Math.max(0, Math.min(360, h));
        currentColor.hsv.s = Math.max(0, Math.min(100, s));
        currentColor.hsv.v = Math.max(0, Math.min(100, v));

        currentHue = currentColor.hsv.h;

        // Обновление производных цветовых моделей
        updateRGBValuesFromHSV();
        updateLABValues();
        updateAllDisplays();
    }

    // Обработка обновления LAB значений
    function labValuesUpdated(l, a, b) {
        // Проверка диапазонов и обрезка значений
        if (l < 0 || l > 100 || a < -128 || a > 127 || b < -128 || b > 127) {
            showNotification('Цветовые значения были обрезаны для соответствия диапазону LAB');
        }

        // Обновление LAB значений с ограничением диапазона
        currentColor.lab.l = Math.max(0, Math.min(100, l));
        currentColor.lab.a = Math.max(-128, Math.min(127, a));
        currentColor.lab.b = Math.max(-128, Math.min(127, b));

        // Обновление производных цветовых моделей
        updateRGBValuesFromLAB();
        updateHSVValues();
        updateAllDisplays();
        drawColorPicker();
        updateColorPickerCursor();
        updateHueSliderCursor();
    }

    // Обновление всех элементов отображения на основе текущего цвета
    function updateAllDisplays() {
        // Обновление блока отображения цвета
        document.getElementById('colorDisplay').style.backgroundColor =
            `rgb(${currentColor.rgb.r}, ${currentColor.rgb.g}, ${currentColor.rgb.b})`;

        // Обновление HEX значения
        document.getElementById('hexInput').value =
            `#${componentToHex(currentColor.rgb.r)}${componentToHex(currentColor.rgb.g)}${componentToHex(currentColor.rgb.b)}`;

        // Обновление RGB элементов управления
        document.getElementById('rSlider').value = currentColor.rgb.r;
        document.getElementById('rInput').value = currentColor.rgb.r;
        document.getElementById('gSlider').value = currentColor.rgb.g;
        document.getElementById('gInput').value = currentColor.rgb.g;
        document.getElementById('rgbBSlider').value = currentColor.rgb.b;
        document.getElementById('rgbBInput').value = currentColor.rgb.b;

        // Обновление HSV элементов управления
        document.getElementById('hSlider').value = Math.round(currentColor.hsv.h);
        document.getElementById('hInput').value = Math.round(currentColor.hsv.h);
        document.getElementById('sSlider').value = Math.round(currentColor.hsv.s);
        document.getElementById('sInput').value = Math.round(currentColor.hsv.s);
        document.getElementById('vSlider').value = Math.round(currentColor.hsv.v);
        document.getElementById('vInput').value = Math.round(currentColor.hsv.v);

        // Обновление LAB элементов управления
        document.getElementById('lSlider').value = Math.round(currentColor.lab.l);
        document.getElementById('lInput').value = Math.round(currentColor.lab.l);
        document.getElementById('aSlider').value = Math.round(currentColor.lab.a);
        document.getElementById('aInput').value = Math.round(currentColor.lab.a);
        document.getElementById('bSlider').value = Math.round(currentColor.lab.b);
        document.getElementById('bInput').value = Math.round(currentColor.lab.b);
    }

    // Преобразование HSV в RGB
    function updateRGBValuesFromHSV() {
        let h = (currentColor.hsv.h % 360) / 60;
        let s = currentColor.hsv.s / 100;
        let v = currentColor.hsv.v / 100;

        // Вычисление промежуточных значений
        const c = v * s;
        const x = c * (1 - Math.abs(h % 2 - 1));
        const m = v - c;

        let r, g, b;

        // Определение сектора цветового круга
        if (h >= 0 && h < 1) {
            r = c; g = x; b = 0;
        } else if (h >= 1 && h < 2) {
            r = x; g = c; b = 0;
        } else if (h >= 2 && h < 3) {
            r = 0; g = c; b = x;
        } else if (h >= 3 && h < 4) {
            r = 0; g = x; b = c;
        } else if (h >= 4 && h < 5) {
            r = x; g = 0; b = c;
        } else {
            r = c; g = 0; b = x;
        }

        // Преобразование в RGB и добавление яркости
        currentColor.rgb.r = Math.round((r + m) * 255);
        currentColor.rgb.g = Math.round((g + m) * 255);
        currentColor.rgb.b = Math.round((b + m) * 255);
    }

    // Преобразование LAB в RGB (через XYZ)
    function updateRGBValuesFromLAB() {
        // Преобразование LAB в XYZ
        const fy = (currentColor.lab.l + 16) / 116;
        const fx = currentColor.lab.a / 500 + fy;
        const fz = fy - currentColor.lab.b / 200;

        const xr = fx > 0.206893 ? Math.pow(fx, 3) : (fx - 16/116) / 7.787;
        const yr = fy > 0.206893 ? Math.pow(fy, 3) : (fy - 16/116) / 7.787;
        const zr = fz > 0.206893 ? Math.pow(fz, 3) : (fz - 16/116) / 7.787;

        // Денормализация по стандартному источнику света D65
        const x = xr * 0.95047;
        const y = yr;
        const z = zr * 1.08883;

        // Преобразование XYZ в RGB
        let r = x * 3.2404542 + y * -1.5371385 + z * -0.4985314;
        let g = x * -0.9692660 + y * 1.8760108 + z * 0.0415560;
        let b = x * 0.0556434 + y * -0.2040259 + z * 1.0572252;

        // Гамма-коррекция
        r = r > 0.0031308 ? 1.055 * Math.pow(r, 1/2.4) - 0.055 : 12.92 * r;
        g = g > 0.0031308 ? 1.055 * Math.pow(g, 1/2.4) - 0.055 : 12.92 * g;
        b = b > 0.0031308 ? 1.055 * Math.pow(b, 1/2.4) - 0.055 : 12.92 * b;

        // Обновление RGB значений с ограничением диапазона
        currentColor.rgb.r = Math.round(Math.max(0, Math.min(1, r)) * 255);
        currentColor.rgb.g = Math.round(Math.max(0, Math.min(1, g)) * 255);
        currentColor.rgb.b = Math.round(Math.max(0, Math.min(1, b)) * 255);
    }

    // Преобразование RGB в HSV
    function updateHSVValues() {
        // Нормализация RGB значений
        let r = currentColor.rgb.r / 255;
        let g = currentColor.rgb.g / 255;
        let b = currentColor.rgb.b / 255;

        // Вычисление максимального, минимального и разницы
        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        const delta = max - min;

        let h = 0;
        let s = max === 0 ? 0 : delta / max;
        const v = max;

        // Вычисление оттенка
        if (delta !== 0) {
            if (max === r) {
                h = ((g - b) / delta) % 6;
            } else if (max === g) {
                h = (b - r) / delta + 2;
            } else {
                h = (r - g) / delta + 4;
            }

            h = h * 60;
            if (h < 0) h += 360;
        }

        // Обновление HSV значений
        currentColor.hsv.h = Math.round(h);
        currentColor.hsv.s = Math.round(s * 100);
        currentColor.hsv.v = Math.round(v * 100);
        currentHue = currentColor.hsv.h;
    }

    // Преобразование RGB в LAB (через XYZ)
    function updateLABValues() {
        // Нормализация RGB значений
        let r = currentColor.rgb.r / 255;
        let g = currentColor.rgb.g / 255;
        let b = currentColor.rgb.b / 255;

        // Гамма-коррекция
        r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
        g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
        b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;

        // Преобразование в XYZ с использованием стандартной матрицы
        const x = r * 0.4124564 + g * 0.3575761 + b * 0.1804375;
        const y = r * 0.2126729 + g * 0.7151522 + b * 0.0721750;
        const z = r * 0.0193339 + g * 0.1191920 + b * 0.9503041;

        // Нормализация по стандартному источнику света D65
        const xn = x / 0.95047;
        const yn = y;
        const zn = z / 1.08883;

        // Преобразование в LAB
        const fx = xn > 0.008856 ? Math.pow(xn, 1/3) : (7.787 * xn) + (16/116);
        const fy = yn > 0.008856 ? Math.pow(yn, 1/3) : (7.787 * yn) + (16/116);
        const fz = zn > 0.008856 ? Math.pow(zn, 1/3) : (7.787 * zn) + (16/116);

        const lVal = (116 * fy) - 16;
        const aVal = 500 * (fx - fy);
        const bVal = 200 * (fy - fz);

        // Обновление LAB значений
        currentColor.lab.l = Math.round(lVal);
        currentColor.lab.a = Math.round(aVal);
        currentColor.lab.b = Math.round(bVal);
    }

    // Преобразование компонента цвета в HEX строку
    function componentToHex(c) {
        return parseInt(c, 10).toString(16).padStart(2, '0');
    }

    // Показать уведомление
    function showNotification(message) {
        notification.textContent = message;
        notification.classList.add('show');

        // Очистка предыдущего таймаута
        if (notificationTimeout) {
            clearTimeout(notificationTimeout);
        }

        // Автоматическое скрытие уведомления через 3 секунды
        notificationTimeout = setTimeout(() => {
            notification.classList.remove('show');
        }, 3000);
    }
</script>
</body>
</html>